data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследовать не только unemp)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
# разбиваем выборку
X.train <- X[tr, ]
X.test <- X[te, ]
y.train <- y[tr]
y.test <- y[tr]
# проводим предварительную кросс-валидацию  для нахождения best lambda
datei <- dates[last(te)]
m_lasso <- glmnet(X.train, y.train, alpha = 1, lambda = 0.03784811)
#print(m_lasso)
print(plot(m_lasso, xvar = "dev", label = TRUE))
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследовать не только unemp)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
# разбиваем выборку
X.train <- X[tr, ]
X.test <- X[te, ]
y.train <- y[tr]
y.test <- y[tr]
# проводим предварительную кросс-валидацию  для нахождения best lambda
datei <- dates[last(te)]
m_lasso <- glmnet(X.train, y.train, alpha = 1, lambda = 0.03784811)
#print(m_lasso)
print(plot(m_lasso, xvar = "lambda", label = TRUE))
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследовать не только unemp)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
# разбиваем выборку
X.train <- X[tr, ]
X.test <- X[te, ]
y.train <- y[tr]
y.test <- y[tr]
# проводим предварительную кросс-валидацию  для нахождения best lambda
datei <- dates[last(te)]
m_lasso <- glmnet(X.train, y.train, alpha = 1, lambda = seq(0.03784811, 1/2000, length=100))
#print(m_lasso)
print(plot(m_lasso, xvar = "lambda", label = TRUE))
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
names(df_tf)
# НАДО Поменять даты на ноябрь 2001 - январь 2017!!!
# Panel data ----
rm(list=ls())
load("tfdata_panel.RData")
# Panel data import ----
# Загрузим дата фрейм (предварительно), что бы было легче определить, какие переменные будем использовать
series <- series_info %>%
filter(freq == 12)
df_raw <- sophisthse(series.name = series$table %>% unique, output = "data.frame")
df <- df_raw %>%
filter(!is.na(UNEMPL_M_SH),
`T` >= zoo::as.yearmon("2001-11-01"),
`T` <= zoo::as.yearmon("2017-01-01"))
nonmis <- sapply(df, function(y) sum(length(which(is.na(y))))) %>%
data.frame %>%
rownames_to_column("tname") %>%
filter(`.` == 0) %>%
pull(tname)
df %<>% select(nonmis)
# пропущенных значений нет
missmap(df)
# теперь определим ряды, у которых уже есть пара в виде очищенного от сезонности ряда
nonsa <- expand.grid(cn1 = colnames(df[,-1]), cn2 = colnames(df[,-1]), stringsAsFactors = FALSE) %>%
as.tibble %>%
mutate(remove = ifelse(cn1 == paste0(cn2, "_SA"),cn2, ifelse(cn2 == paste0(cn1, "_SA"),cn1, NA))) %>%
na.omit %>%
pull(remove) %>%
unique # добавим время и UNEMPL_M
df %<>% select(-nonsa)
# получим 84 ряда
# эти ряды будем использовать при скачивании данных формате zoo
df <- sophisthse(series.name = nonmis[which(!nonmis %in% c("T","UNEMPL_M"))], output = "zoo") %>%
window(start = zoo::as.yearmon("2001-11-01"),
end = zoo::as.yearmon("2017-01-01"))
# удалим те ряды, у которые есть пара, уже очищенная от сезонности
df %<>% .[,which(!names(.) %in% nonsa)]
# сохраним сырые данные
save(df, file = "rawdata_panel.RData")
# Трансформируем ряды (приведём к стационарном виду). Это делать не обязательно, поэтому позднее для
# некоторых моделей попробуем не использовать трансформацию
# ряд GKO_M имеет пропуск
df$GKO_M <- na.locf(df$GKO_M)
get.stationary.panel <- function(df){
dates <- time(df)
result <- df %>%
as.xts %>%
as.list %>%
imap(function(x,i){
x_dec <- decompose(x)
x <- x_dec$x - x_dec$seasonal
# проводим adf test для
# проводим adf test для простой разности
d0 <- adf.test(x) %>% .$p.value
if(d0<=0.05){
type <-  "d0"
x_stat <- x
} else{
d1 <- adf.test(diff.xts(x) %>% na.omit) %>% .$p.value
if(d1<=0.05){
type <-  "d1"
x_stat <- diff.xts(x)
} else{
log_d1 <- 1
try({
log_d1 <- adf.test(diff.xts(log(x)) %>% na.omit) %>% .$p.value
})
if(log_d1<=0.05){
type <- "log_d1"
x_stat <- diff.xts(log(x))
} else{
d2 <- adf.test(diff.xts(x, differences = 2) %>% na.omit) %>% .$p.value
if(d2<=0.05){
type <- "d2"
x_stat <- diff.xts(diff.xts(x))
} else{
# сообщений нет
message(i)
message(min(c(d0, d1, log_d1, d2)))
x_stat = x
}
}
}
}
list(typedf = data.frame(tsname = i, type = type, stringsAsFactors = FALSE),
statdf = data.frame(x_stat, stringsAsFactors = FALSE) %>% set_names(i))
})
statdf <- result %>% map_dfc(function(x){
x$statdf
}) %>% as.zoo(order.by = dates)
typedf <- result %>% map_dfr(function(x){
x$typedf
})
list(df = statdf, type = typedf)
}
# получаем транcформированные ряды
df_tf <- get.stationary.panel(df)$df
# данные о типе трансформации
df_tf_type <- get.stationary.panel(df)$type
save(df_tf, df_tf_type, file = "tfdata_panel.RData")
rm(list=ls())
load("tfdata_panel.RData")
load("rawdata_panel.RData")
df
str(df)
str(df_tf)
series <- series_info %>%
filter(freq == 12)
series
df_raw <- sophisthse(series.name = series$table %>% unique, output = "data.frame")
df <- df_raw %>%
filter(!is.na(UNEMPL_M_SH),
`T` >= zoo::as.yearmon("2001-11-01"),
`T` <= zoo::as.yearmon("2017-01-01"))
nonmis <- sapply(df, function(y) sum(length(which(is.na(y))))) %>%
data.frame %>%
rownames_to_column("tname") %>%
filter(`.` == 0) %>%
pull(tname)
missmap(df)
df <- df_raw %>%
filter(!is.na(UNEMPL_M_SH),
`T` >= zoo::as.yearmon("2002-11-01"),
`T` <= zoo::as.yearmon("2016-01-01"))
nonmis <- sapply(df, function(y) sum(length(which(is.na(y))))) %>%
data.frame %>%
rownames_to_column("tname") %>%
filter(`.` == 0) %>%
pull(tname)
missmap(df)
df %<>% select(nonmis)
# пропущенных значений нет
missmap(df)
# теперь определим ряды, у которых уже есть пара в виде очищенного от сезонности ряда
nonsa <- expand.grid(cn1 = colnames(df[,-1]), cn2 = colnames(df[,-1]), stringsAsFactors = FALSE) %>%
as.tibble %>%
mutate(remove = ifelse(cn1 == paste0(cn2, "_SA"),cn2, ifelse(cn2 == paste0(cn1, "_SA"),cn1, NA))) %>%
na.omit %>%
pull(remove) %>%
unique # добавим время и UNEMPL_M
df %<>% select(-nonsa)
df <- sophisthse(series.name = nonmis[which(!nonmis %in% c("T","UNEMPL_M"))], output = "zoo") %>%
window(start = zoo::as.yearmon("2001-11-01"),
end = zoo::as.yearmon("2017-01-01"))
missmap(df)
# удалим те ряды, у которые есть пара, уже очищенная от сезонности
df %<>% .[,which(!names(.) %in% nonsa)]
# сохраним сырые данные
save(df, file = "rawdata_panel.RData")
rm(list = ls())
load("rawdata_panel.RData")
# Трансформируем ряды (приведём к стационарном виду). Это делать не обязательно, поэтому позднее для
# некоторых моделей попробуем не использовать трансформацию
# ряд GKO_M имеет пропуск
df$GKO_M <- na.locf(df$GKO_M)
get.stationary.panel <- function(df){
dates <- time(df)
result <- df %>%
as.xts %>%
as.list %>%
imap(function(x,i){
x_dec <- decompose(x)
x <- x_dec$x - x_dec$seasonal
# проводим adf test для
# проводим adf test для простой разности
d0 <- adf.test(x) %>% .$p.value
if(d0<=0.05){
type <-  "d0"
x_stat <- x
} else{
d1 <- adf.test(diff.xts(x) %>% na.omit) %>% .$p.value
if(d1<=0.05){
type <-  "d1"
x_stat <- diff.xts(x)
} else{
log_d1 <- 1
try({
log_d1 <- adf.test(diff.xts(log(x)) %>% na.omit) %>% .$p.value
})
if(log_d1<=0.05){
type <- "log_d1"
x_stat <- diff.xts(log(x))
} else{
d2 <- adf.test(diff.xts(x, differences = 2) %>% na.omit) %>% .$p.value
if(d2<=0.05){
type <- "d2"
x_stat <- diff.xts(diff.xts(x))
} else{
# сообщений нет
message(i)
message(min(c(d0, d1, log_d1, d2)))
x_stat = x
}
}
}
}
list(typedf = data.frame(tsname = i, type = type, stringsAsFactors = FALSE),
statdf = data.frame(x_stat, stringsAsFactors = FALSE) %>% set_names(i))
})
statdf <- result %>% map_dfc(function(x){
x$statdf
}) %>% as.zoo(order.by = dates)
typedf <- result %>% map_dfr(function(x){
x$typedf
})
list(df = statdf, type = typedf)
}
# получаем транcформированные ряды
df_tf <- get.stationary.panel(df)$df
# данные о типе трансформации
df_tf_type <- get.stationary.panel(df)$type
missmap(df)
save(df_tf, df_tf_type, file = "tfdata_panel.RData")
get.stationary.panel <- function(df){
dates <- time(df)
result <- df %>%
na.omit %>%
as.xts %>%
as.list %>%
imap(function(x,i){
x_dec <- decompose(x)
x <- x_dec$x - x_dec$seasonal
# проводим adf test для
# проводим adf test для простой разности
d0 <- adf.test(x) %>% .$p.value
if(d0<=0.05){
type <-  "d0"
x_stat <- x
} else{
d1 <- adf.test(diff.xts(x) %>% na.omit) %>% .$p.value
if(d1<=0.05){
type <-  "d1"
x_stat <- diff.xts(x)
} else{
log_d1 <- 1
try({
log_d1 <- adf.test(diff.xts(log(x)) %>% na.omit) %>% .$p.value
})
if(log_d1<=0.05){
type <- "log_d1"
x_stat <- diff.xts(log(x))
} else{
d2 <- adf.test(diff.xts(x, differences = 2) %>% na.omit) %>% .$p.value
if(d2<=0.05){
type <- "d2"
x_stat <- diff.xts(diff.xts(x))
} else{
# сообщений нет
message(i)
message(min(c(d0, d1, log_d1, d2)))
x_stat = x
}
}
}
}
list(typedf = data.frame(tsname = i, type = type, stringsAsFactors = FALSE),
statdf = data.frame(x_stat, stringsAsFactors = FALSE) %>% set_names(i))
})
statdf <- result %>% map_dfc(function(x){
x$statdf
}) %>% as.zoo(order.by = dates)
typedf <- result %>% map_dfr(function(x){
x$typedf
})
list(df = statdf, type = typedf)
}
# получаем транcформированные ряды
df_tf <- get.stationary.panel(df)$df
# данные о типе трансформации
df_tf_type <- get.stationary.panel(df)$type
df_tf
df_tf %>% str
save(df_tf, df_tf_type, file = "tfdata_panel.RData")
rm(list=ls())
load("tfdata_panel.RData")
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследовать не только unemp)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
# разбиваем выборку
X.train <- X[tr, ]
X.test <- X[te, ]
y.train <- y[tr]
y.test <- y[tr]
# проводим предварительную кросс-валидацию  для нахождения best lambda
datei <- dates[last(te)]
m_lasso <- glmnet(X.train, y.train, alpha = 1, lambda = seq(0.03784811, 1/2000, length=100))
#print(m_lasso)
print(plot(m_lasso, xvar = "lambda", label = TRUE))
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
df$CPI_M_CHI <- lag.xts(df$CPI_M_CHI, k = -1)
df %<>% na.omit
dates <- time(df)
y <- df$UNEMPL_M_SH
X <- model.matrix(UNEMPL_M_SH~., data = df)
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследовать не только unemp)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
# разбиваем выборку
X.train <- X[tr, ]
X.test <- X[te, ]
y.train <- y[tr]
y.test <- y[tr]
# проводим предварительную кросс-валидацию  для нахождения best lambda
datei <- dates[last(te)]
m_lasso <- glmnet(X.train, y.train, alpha = 1, lambda = seq(0.03784811, 1/2000, length=100))
#print(m_lasso)
print(plot(m_lasso, xvar = "lambda", label = TRUE))
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
df <- df_tf
df$CPI_M_CHI <- lag.xts(df$CPI_M_CHI, k = -1)
df %<>% na.omit
dates <- time(df)
y <- df$UNEMPL_M_SH
X <- model.matrix(UNEMPL_M_SH~., data = df)
set.seed(2-19)
set.seed(2019)
lmbd <- c()
for(i in 1:100){
lambdas <- seq(0.04237538+1/100, 0.04237538-1/100, length = 100)
cv.out <- cv.glmnet(X, y, lambda = lambdas)
lmbd <- c(lmbd,cv.out$lambda.1se)
}
mean(lmbd)
cv.out <- cv.glmnet(X, y)
qplot(cv.out$lambda, cv.out$nzero)
qplot(cv.out$lambda, cv.out$cvm)
qplot(cv.out$lambda, cv.out$cvm+cv.out$cvsd)
ggplot(cv.out) + geom_line(aes(x = lambda, y = cvm))
ggplot() + geom_line(aes(x = cv.out$lambda, y = cv.out$cvm, colour = "mean"))+ geom_line(aes(x = cv.out$lambda, y = cv.out$cvup, colour = "up"))+ geom_line(aes(x = cv.out$lambda, y = cv.out$cvlo, colour = "lo"))
cv.out$lambda.min
cv.out$lambda.min
cv.out$lambda.1se
lm(UNEMPL_M_SH~., data = df_tf) %>% summary
glmnet(X, y, lambda = cv.out$lambda.min)
glmnet(X, y, lambda = c(cv.out$lambda.min, cv.out$lambda.1se))
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min)
cv.out$lambda.min
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "lambda")
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "lambda")
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "dev")
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "dev")
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "dev")
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "dev")
df <- df_tf
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
y <- df$UNEMPL_M_SH
X <- model.matrix(UNEMPL_M_SH~., data = df)
set.seed(2019)
cv.out <- cv.glmnet(X, y)
glmnet(X, y,lambda.min.ratio = cv.out$lambda.min) %>% plot(xvar = "dev")
qplot(cv.out$lambda, cv.out$cvm)
qplot(cv.out$lambda, cv.out$nzero)
qplot(log(cv.out$lambda), cv.out$nzero)
