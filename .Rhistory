diff(df_tf$UNEMPL_M_SH, lag = -1)
lag(df_tf$UNEMPL_M_SH, lag = -1)
df_tf$UNEMPL_M_SH
lag(df_tf$UNEMPL_M_SH, lag = 1)
lag(df_tf$UNEMPL_M_SH, lag = -1)
lead(df_tf$UNEMPL_M_SH)
lag.xts(df_tf$UNEMPL_M_SH, k = -1)
lag.xts(df_tf$UNEMPL_M_SH, k = -1) %>% class
# Загрузим дата фрейм (предварительно), что бы было легче определить, какие переменные будем использовать
series <- series_info %>%
filter(freq == 12)
df_raw <- sophisthse(series.name = series$table %>% unique, output = "data.frame")
df <- df_raw %>%
filter(!is.na(UNEMPL_M_SH),
`T` >= zoo::as.yearmon("2001-11-01"),
`T` <= zoo::as.yearmon("2016-12-01"))
nonmis <- sapply(df, function(y) sum(length(which(is.na(y))))) %>%
data.frame %>%
rownames_to_column("tname") %>%
filter(`.` == 0) %>%
pull(tname)
# пропущенных значений нет
missmap(df)
df %<>% select(nonmis)
# пропущенных значений нет
missmap(df)
df_raw <- sophisthse(series.name = series$table %>% unique, output = "data.frame")
df <- df_raw %>%
filter(!is.na(UNEMPL_M_SH),
`T` >= zoo::as.yearmon("2001-11-01"),
`T` <= zoo::as.yearmon("2017-01-01"))
df <- df_raw %>%
filter(!is.na(UNEMPL_M_SH),
`T` >= zoo::as.yearmon("2001-11-01"),
`T` <= zoo::as.yearmon("2017-01-01"))
nonmis <- sapply(df, function(y) sum(length(which(is.na(y))))) %>%
data.frame %>%
rownames_to_column("tname") %>%
filter(`.` == 0) %>%
pull(tname)
# пропущенных значений нет
missmap(df)
df %<>% select(nonmis)
# пропущенных значений нет
missmap(df)
# теперь определим ряды, у которых уже есть пара в виде очищенного от сезонности ряда
nonsa <- expand.grid(cn1 = colnames(df[,-1]), cn2 = colnames(df[,-1]), stringsAsFactors = FALSE) %>%
as.tibble %>%
mutate(remove = ifelse(cn1 == paste0(cn2, "_SA"),cn2, ifelse(cn2 == paste0(cn1, "_SA"),cn1, NA))) %>%
na.omit %>%
pull(remove) %>%
unique # добавим время и UNEMPL_M
df %<>% select(-nonsa)
df <- sophisthse(series.name = nonmis[which(!nonmis %in% c("T","UNEMPL_M"))], output = "zoo") %>%
window(start = zoo::as.yearmon("2002-01-01"),
end = zoo::as.yearmon("2016-12-01"))
# удалим те ряды, у которые есть пара, уже очищенная от сезонности
df %<>% .[,which(!names(.) %in% nonsa)]
df <- sophisthse(series.name = nonmis[which(!nonmis %in% c("T","UNEMPL_M"))], output = "zoo") %>%
window(start = zoo::as.yearmon("2001-11-01"),
end = zoo::as.yearmon("2017-01-01"))
# удалим те ряды, у которые есть пара, уже очищенная от сезонности
df %<>% .[,which(!names(.) %in% nonsa)]
missmap(df)
# сохраним сырые данные
save(df, file = "rawdata_panel.RData")
# Трансформируем ряды (приведём к стационарном виду). Это делать не обязательно, поэтому позднее для
# некоторых моделей попробуем не использовать трансформацию
# ряд GKO_M имеет пропуск
df$GKO_M <- na.locf(df$GKO_M)
get.stationary.panel <- function(df){
dates <- time(df)
result <- df %>%
as.xts %>%
as.list %>%
imap(function(x,i){
x_dec <- decompose(x)
x <- x_dec$x - x_dec$seasonal
# проводим adf test для
# проводим adf test для простой разности
d0 <- adf.test(x) %>% .$p.value
if(d0<=0.05){
type <-  "d0"
x_stat <- x
} else{
d1 <- adf.test(diff.xts(x) %>% na.omit) %>% .$p.value
if(d1<=0.05){
type <-  "d1"
x_stat <- diff.xts(x)
} else{
log_d1 <- 1
try({
log_d1 <- adf.test(diff.xts(log(x)) %>% na.omit) %>% .$p.value
})
if(log_d1<=0.05){
type <- "log_d1"
x_stat <- diff.xts(log(x))
} else{
d2 <- adf.test(diff.xts(x, differences = 2) %>% na.omit) %>% .$p.value
if(d2<=0.05){
type <- "d2"
x_stat <- diff.xts(diff.xts(x))
} else{
# сообщений нет
message(i)
message(min(c(d0, d1, log_d1, d2)))
x_stat = x
}
}
}
}
list(typedf = data.frame(tsname = i, type = type, stringsAsFactors = FALSE),
statdf = data.frame(x_stat, stringsAsFactors = FALSE) %>% set_names(i))
})
statdf <- result %>% map_dfc(function(x){
x$statdf
}) %>% as.zoo(order.by = dates)
typedf <- result %>% map_dfr(function(x){
x$typedf
})
list(df = statdf, type = typedf)
}
# получаем транcформированные ряды
df_tf <- get.stationary.panel(df)$df
# данные о типе трансформации
df_tf_type <- get.stationary.panel(df)$type
save(df_tf, df_tf_type, file = "tfdata_panel.RData")
rm(list=ls())
load("tfdata_panel.RData")
na.omit(df_tf) %>% str
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
print(dates)
stop()
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y <
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r()
get.panel.r(df_tf)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
model2 <- cv.glmnet(x = data2.x, y= data2.y, standardize = TRUE)
get.panel.r()
get.panel.r(df_tf)
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
print(Y)
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
print(TS$test)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
print(Y)
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
print(df_train$UNEMPL_M_SH)
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
print(tr)
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
print(df_train$UNEMPL_M_SH)
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
print(df_train)
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
print(df_train$UNEMPL_M_SH)
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
print(df_train)
print(df_train$UNEMPL_M_SH)
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
## LASSO ----
get.panel.r <- function(df, window, horizon){
if(!"zoo" %in% class(df)){
stop("df must be 'zoo'")
}
# важно, что предсказываем мы следующее значение безработицы
# (преобразуем здесь, а не внутри import.R, потому что, возможно, будем исследвоать не только unemp)
df$UNEMPL_M_SH <- lag.xts(df$UNEMPL_M_SH, k = -1)
df %<>% na.omit
dates <- time(df)
expand.grid(window = window, horizon = horizon) %>%
split(seq(nrow(.))) %>% map_dfr(function(x){
TS <- createTimeSlices(dates, initialWindow = x$window,
horizon = x$horizon,
fixedWindow = TRUE,
skip = FALSE)
map2_dfr(TS$train, TS$test, function(tr, te){
df_train <- df %>%
window(start = dates[first(tr)],
end = dates[last(tr)])
df_test <- df %>%
window(start = dates[first(te)],
end = dates[last(te)])
date_test <- dates[last(te)]
print(df_train$UNEMPL_M_SH)
X <- model.matrix(UNEMPL_M_SH~., data = df_train)
Y < df_train$UNEMPL_M_SH
lambdas <- seq(50, 0.1, length = 30)
m_lassso <- glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(m_lasso, xvar = "lambda", label = TRUE)
stop()
y_pred <- forecast(model, h = x$horizon) %>% as.data.frame %>% .[,1] %>% last
data.frame(date =date_test,
window = x$window,
horizon = x$horizon,
y_true = y_test,
y_pred= y_pred)
})
}) %>%
mutate(model = "arp")
}
get.panel.r(df_tf, 120, 6)
